---
description: 작업 복잡도 분류, Phase별 에이전트 위임, 병렬 디스패치, 스킬 조합 등 오케스트레이션 전략. Subagent에 작업을 위임하거나 에이전트를 선택할 때 적용.
alwaysApply: false
source: origin
---

# Agent Delegation — 오케스트레이션 및 에이전트 위임 가이드

> 이 룰은 의도적으로 "Applied intelligently" 방식이며, 스킬로 마이그레이션하지 않습니다.

Subagent에 작업을 위임할 때 자동 적용되는 가이드입니다.

## 작업 복잡도 분류

작업 복잡도에 따라 적절한 워크플로우를 선택합니다.

| 복잡도 | 기준 | 워크플로우 |
|--------|------|-----------|
| Complex | 3개 이상 파일, 새 Feature, 대규모 리팩토링 | 4-Phase 전체 (Analyze → Plan → Execute → Verify), 실패 시 Phase 2 회귀 |
| Medium | 버그 수정, 단일 API 추가, 마이그레이션 | debugger/implementer/migrator → reviewer |
| Simple | 단일 파일 수정, 질문, 설명 | Subagent 없이 직접 처리 (overhead 방지) |
| Autonomous | 대규모 자율 작업 | `/ralph` 또는 `/autopilot` 커맨드 사용 |

## 커스텀 에이전트 (프로젝트 컨벤션 적용)

다음 에이전트는 `.cursor/agents/`에 정의되어 프로젝트 컨벤션과 context.mdc를 로드합니다:

### Phase 0: Analyze

| 에이전트 | 역할 | readonly | model |
|----------|------|----------|-------|
| analyst | 사전 분석, 요구사항 정제, 리스크 식별 | true | fast |
| researcher | 기술 리서치, 라이브러리/API 비교 분석 | true | fast |
| vision | 스크린샷/목업 시각적 분석, 디자인 사양 추출 | true | fast |

### Phase 1: Plan

| 에이전트 | 역할 | readonly | model |
|----------|------|----------|-------|
| planner | 전략 기획, 영향도 분석, 단계별 계획 | true | inherit |
| critic | 계획 비판적 검토, 완전성/리스크 검증 | true | fast |
| architect | 아키텍처 구조 분석, 모듈 경계, 의존성 그래프 | true | fast |
| designer | UI/UX 패턴 평가, 접근성, 디자인 시스템 분석 | true | fast |

### Phase 2: Execute

| 에이전트 | 역할 | readonly | model |
|----------|------|----------|-------|
| implementer | Feature 구현, 프로젝트 패턴 준수 | false | inherit |
| debugger | 디버깅, 메모리 릭, 성능 이슈 진단/수정 | false | inherit |
| build-fixer | 빌드 오류 진단, 컴파일/타입/의존성 수정 | false | inherit |
| migrator | API/프레임워크 마이그레이션, 스키마 변경 | false | inherit |
| tdd-guide | TDD Red-Green-Refactor 워크플로우 가이드 | false | inherit |

### Phase 3: Verify

| 에이전트 | 역할 | readonly | model |
|----------|------|----------|-------|
| reviewer | 코드 리뷰, 패턴 준수, 리팩토링 검증 | true | fast |
| qa-tester | 수용 기준 검증, 엣지케이스, 테스트 커버리지 | true | fast |
| security-reviewer | 보안 취약점 분석, 인젝션/XSS/시크릿 노출 | true | fast |
| doc-writer | README, API 문서, 아키텍처 문서, 온보딩 가이드 | false | inherit |

## 빌트인 전용 subagent_type

커스텀 에이전트가 없는 인프라 subagent_type:

| subagent_type | 용도 |
|---------------|------|
| explore | 코드베이스 탐색, 파일 검색, 패턴 분석 |
| shell | git, npm, 빌드 도구 등 CLI 작업 |
| browser-use | 웹 UI 테스트, 스크린샷, 폼 자동화 |
| generalPurpose | 복합 검색, 코드 조사, 멀티스텝 실행 |

위 커스텀 에이전트 16개는 동명의 빌트인 subagent_type이 존재하지만, 커스텀 에이전트가 context.mdc를 로드하여 프로젝트 컨벤션을 적용하므로 우선 사용됩니다.

---

## Phase별 위임 규칙

### Phase 0: Analyze
- 복잡한 Feature 요청 시: analyst에 위임
- 기술 리서치/비교 분석 시: researcher에 위임
- 스크린샷/목업 분석 시: vision에 위임
- 심층 코드베이스 탐색 시: deep-search 스킬 적용

### Phase 1: Plan
- 전략 기획 요청 시: planner에 위임 → critic으로 계획 검증
- 아키텍처 결정 필요 시: architect에 위임 → critic으로 검증
- UI/UX 설계 분석 시: designer에 위임
- PRD 필요 시: prd 스킬 적용
- 조합: architect + planner (구조 결정 → 구현 계획), designer + implementer (디자인 분석 → 구현)

### Phase 2: Execute
- Feature 구현 시: implementer에 위임
- UI 구현 시: implementer (design-principles 스킬 적용)
- 빌드 오류 시: build-fixer에 위임
- 런타임 버그/성능 이슈 시: debugger에 위임
- TDD 워크플로우 시: tdd-guide에 위임
- API/프레임워크 마이그레이션 시: migrator에 위임
- 대규모 자율 작업 시: /autopilot 또는 /ralph 커맨드 적용
- 구조적 리팩토링 시: ast-refactor 스킬 안내

### Phase 3: Verify
- 코드 리뷰 시: reviewer에 위임
- 수용 기준/테스트 커버리지 검증 시: qa-tester에 위임
- 테스트 코드 작성 필요 시: qa-tester → implementer 순차 (갭 분석 → 구현)
- 보안 검토 시: security-reviewer에 위임
- 문서화 시: doc-writer에 위임

### Support (Phase 횡단)
- 라이브러리/API 조사 시: researcher에 위임 또는 research 스킬
- 코드베이스 탐색 시: explore subagent
- 브라우저 테스트 시: browser-use subagent
- 터미널 작업 시: shell subagent

### Direct Handling
- 단순한 작업이나 질문은 Subagent 없이 직접 처리

---

## Parallel Agent Dispatch

독립적인 작업은 Task tool로 병렬 실행합니다 (최대 4개):

- 분석 단계: analyst + deep-search 동시 실행
- 기획 단계: planner + deep-search 동시 실행
- 구현 완료 후: reviewer + qa-tester 동시 실행
- 탐색 단계: Grep + SemanticSearch + Glob 동시 실행

---

## Skill Composition (3-Layer)

스킬을 레이어로 조합하여 실행 전략을 결정합니다:

```
Guarantee Layer (선택, 0-1):  ralph — "검증 완료까지 멈추지 않음"
Enhancement Layer (0-N):      autopilot(병렬) | tdd(테스트우선) | ecomode(절약)
Execution Layer (필수, 1):    default(구현) | orchestrate(조율) | planner(기획)
```

공식: [Execution] + [0-N Enhancement] + [Optional Guarantee]

---

## Completion Criteria Reference

verify-loop 스킬에 정의된 4-Level 기준을 참조합니다:

| Level | 이름 | 적용 상황 |
|-------|------|----------|
| 1 | Minimal | 단순 수정 |
| 2 | Standard | 일반 작업 |
| 3 | Thorough | Feature 구현 |
| 4 | Production | 릴리즈 |

프로젝트 설정의 `defaults.completionLevel`이 프로젝트 기본값을 결정합니다.

---

## 에이전트 생성 가이드라인

### Emoji 선택 규칙

| 도메인 | Emoji | 설명 |
|--------|-------|------|
| UI 구현 | 📱 | 화면, 컴포넌트, 레이아웃 작업 |
| 아키텍처 설계/리팩토링 | 🏗️ | 구조 개선, 패턴 적용, 모듈화 |
| 디버깅/문제 해결 | 🔍 | 버그 수정, 성능 개선 |
| 마이그레이션/전환 | 🔄 | 언어 전환, 프레임워크 업그레이드 |
| 테스트 작성 | 🧪 | 단위/통합 테스트, 품질 보증 |
| 데이터 처리 | 💾 | 네트워크, 로컬 DB, 캐싱 |
| 보안/인증 | 🔐 | 로그인, 암호화, 권한 관리 |
| 성능 최적화 | ⚡ | 속도 개선, 메모리 최적화 |
| 레거시 코드 분석 | 🔎 | 리버스 엔지니어링, 마이그레이션 로드맵 |
| 디자인 구현 | 🎨 | Figma MCP를 활용한 UI 코드 생성 |

### Synapse_CoR 변수 채우기

- ${emoji}: 작업 도메인에 맞는 이모지 (위 테이블 참조)
- ${role}: [구체적 도메인] 전문가
- ${context}: 사용자 상황과 요구사항
- ${goal}: 달성할 목표
- ${tools}: context.mdc의 프레임워크 + 활성화된 스킬
- ${reasoned steps}: todo-list를 사용한 단계별 실행 계획 (3~7단계)
- ${completion}: 측정 가능한 완료 조건
- ${first step, question}: 명확한 질문이나 다음 행동

### 예시: 로그인 화면 구현

📱: 저는 UI 설계 및 구현의 전문가입니다. 저는 사용자가 프로젝트에서 로그인 화면을 원한다는 것을 알고 있습니다. 보안적이고 사용자 친화적인 로그인 화면을 구현하기 위해 최선의 방법을 단계별로 결정하겠습니다.
다음 단계를 통해 당신이 목표를 달성하도록 도울 것입니다:

1. 프로젝트의 인증 관련 의존성 확인
2. 기존 아키텍처 패턴 분석
3. 로그인 View 및 ViewModel 구조 설계
4. 입력 검증 로직 구현
5. 접근성 및 반응형 대응
6. 단위 테스트 작성

제 임무는 로그인 화면이 동작하고 모든 테스트가 통과했을 때 종료됩니다.

현재 프로젝트에 인증 관련 라이브러리나 기존 인증 로직이 있는지 확인해도 될까요?
